package logic_fight.character.pokemon;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import audio.SFXUtility;
import graphic.DrawingUtility;
import graphic.IRenderable;
import graphic.IRenderableHolder;
import graphic.PseudoAnimation;
import item.Item;
import javafx.scene.image.Image;
import logic_fight.character.HPStat;
import logic_fight.character.PassiveSkill;
import logic_fight.character.SWTable;
import logic_fight.character.Stat;
import logic_fight.character.activeSkill.ActiveSkill;
import logic_fight.filters.Filter;
import logic_fight.filters.MoveNoOverlapFilter;
import logic_fight.player.Player;
import logic_fight.terrain.FightMap;
import logic_fight.terrain.FightMap.Direction;
import logic_fight.terrain.FightTerrain;
import logic_fight.terrain.Path;
import utility.Clock;
import utility.RandomUtility;
import utility.StringUtility;

public class Pokemon extends AbstractPokemon implements IRenderable {

	// Constants and Variables

	private static final String DEFAULT_IMAGE_FILE_LOCATION = "load/img/pokemon";
	public static final int MAX_ACTIVE_SKILLS = 4;
	public static final int MIN_LEVEL = 1;
	public static final int MAX_LEVEL = 100;

	public static final int DEFAULT_POKEMON_LEVEL = 5;

	private double currentHP, nextTurnTime;
	private Player owner;
	private List<ActiveSkill> activeSkills = new ArrayList<ActiveSkill>();
	private List<PassiveSkill> passiveSkills = new ArrayList<PassiveSkill>();
	// private Stat attack, defense, speed;
	// private HPStat hp;
	private Map<String, Stat> stats = new HashMap<String, Stat>();
	/** Individual value */
	private NonVolatileStatus status = NonVolatileStatus.NORMAL;
	private Pokemon killer;
	private boolean visible = true;

	/**
	 * Holds avaliable paths to move generated by
	 * <code>findBlocksAround()</code>.
	 */
	private ArrayList<Path> paths = new ArrayList<Path>();
	private FightMap currentFightMap = null;
	private FightTerrain currentFightTerrain = null;

	private int level;
	private double currentExp;
	private double lastExpRequired;
	private double nextExpRequired;

	// Enums and inner classes

	/** Type of relocation on <code>fightMap</code>. */
	public static enum MoveType {
		FLY, SWIM, WALK;

		public boolean check(FightTerrain ft) {
			switch (ft.getType()) {
			case WATER:
				return this.equals(SWIM) || this.equals(FLY);
			case ROCK:
			case TREE:
				return this.equals(FLY);
			case GRASS:
			case GROUND:
			default:
				return true;
			}
		}
	}

	// Constructors

	public Pokemon(PokemonTemplate pokemonTemplate, int level, boolean useDefaultActiveSkill) {
		Objects.requireNonNull(pokemonTemplate, "pokemonTemplate Required in Pokemon Constructor");
		if (level < MIN_LEVEL || level > MAX_LEVEL) {
			throw new IllegalArgumentException("Pokemon Constructor : Illegal level for Pokemon "
					+ pokemonTemplate.getName() + ", level=" + level);
		}
		id = pokemonTemplate.id;
		this.level = level;
		this.name = pokemonTemplate.name;

		Stat attack = new Stat(pokemonTemplate.getBaseAttack(), level);
		Stat defense = new Stat(pokemonTemplate.getBaseDefense(), level);
		Stat speed = new Stat(pokemonTemplate.getBaseSpeed(), level);
		HPStat hp = new HPStat(pokemonTemplate.getBaseHP(), level);

		moveRange = pokemonTemplate.moveRange;
		attackRange = pokemonTemplate.attackRange;
		moveType = pokemonTemplate.moveType;

		stats.put("attack", attack);
		stats.put("defense", defense);
		stats.put("speed", speed);
		stats.put("hp", hp);

		primaryElement = pokemonTemplate.primaryElement;
		secondaryElement = pokemonTemplate.secondaryElement;
		levelingRate = pokemonTemplate.levelingRate;
		expYield = pokemonTemplate.expYield;
		catchRate = pokemonTemplate.catchRate;

		updateExpRequired();
		currentExp = levelingRate.getRequiredExperience(level);

		if (useDefaultActiveSkill) {
			pokemonTemplate.getDefaultActiveSkill().stream().forEachOrdered(as -> this.addActiveSkill(as));
		}

		nextTurnTime = 0;
		calculateNextTurnTime();
		resetHP();
		setDefaultImageFileLocation();
		loadImage();
	}

	public Pokemon(PokemonTemplate pokemonTemplate, int level) {
		this(pokemonTemplate, level, true);
	}

	public Pokemon(PokemonTemplate pokemonTemplate, int level, Player owner) {
		this(pokemonTemplate, level);
		owner.addPokemon(this);
	}

	// public Pokemon(int id, int attackStat, int defenceStat, int speed, int
	// hp, int moveRange, int attackRange,
	// MoveType moveType) {
	// this.id = id;
	// attack = new Stat(attackStat, level);
	// defense = new Stat(defenceStat, level);
	// this.hp = new HPStat(hp, level);
	// this.speed = new Stat(speed, level);
	// this.moveRange = moveRange;
	// this.attackRange = attackRange;
	// this.moveType = moveType;
	// stats = Arrays.asList(attack, defense, this.speed, this.hp);
	// nextTurnTime = 0;
	// calculateNextTurnTime();
	// resetHP();
	// setImageFileLocation();
	// }
	//
	// public Pokemon(int id, int attackStat, int defenceStat, int speed, int
	// hp, int moveRange, int attackRange,
	// MoveType moveType, Player owner) {
	// this(id, attackStat, defenceStat, speed, hp, moveRange, attackRange,
	// moveType);
	// this.owner = owner;
	// owner.addPokemon(this);
	// }
	//
	// /**
	// * Load arguments to <code>Pokemon</code> by <code>String[]</code>. </br>
	// * Usage : id attack defence speed fullHP moveRange attackRange moveType.
	// *
	// * @param args
	// * String of arguments.
	// */
	// public Pokemon(String[] args) {
	// id = Integer.parseInt(args[0]);
	// attack = new Stat(Integer.parseInt(args[1]), level);
	// defense = new Stat(Integer.parseInt(args[2]), level);
	// speed = new Stat(Integer.parseInt(args[3]), level);
	// hp = new HPStat(Integer.parseInt(args[4]), level);
	// moveRange = Integer.parseInt(args[5]);
	// attackRange = Integer.parseInt(args[6]);
	// moveType = toMoveType(args[7]).orElse(MoveType.WALK);
	// stats = Arrays.asList(attack, defense, this.speed, this.hp);
	// nextTurnTime = 0;
	// calculateNextTurnTime();
	// resetHP();
	// setImageFileLocation();
	// }

	@Override
	public String toString() {
		return "Pokemon " + this.getName() + " LV." + this.getLevel();
	}

	public void showStats() {
		System.out.println("name : " + getName());
		System.out.println("level : " + level);
		System.out.println(" - attack" + stats.get("attack"));
		System.out.println(" - defense" + stats.get("defense"));
		System.out.println(" - speed" + stats.get("speed"));
		System.out.println(" - hp" + stats.get("hp"));
	}

	/** Use to reset pokemon before entering fight */
	public void enterFight() {
		stats.values().forEach(st -> st.resetStage());
		killer = null;
	}

	// move and attack

	/**
	 * Use to relocate this <code>Pokemon</code> on <code>fightMap</code>.
	 * <code>currentFightTerrain</code> will be automatically generated. Does
	 * not use <code>Filter.check()</code>.
	 * 
	 * @param x
	 *            position
	 * @param y
	 *            position
	 */
	public void move(int x, int y) {
		Objects.requireNonNull(currentFightMap, "Pokemon.move() : [ID=" + id + "].currentFightMap not set");
		if (!currentFightMap.outOfMap(x, y)) {
			this.currentFightTerrain = currentFightMap.getFightTerrainAt(x, y);
		} else {
			this.currentFightTerrain = null;
		}
	}

	public void move(FightTerrain fightTerrain) {
		this.currentFightTerrain = fightTerrain;
	}

	public void attack(Pokemon other, ActiveSkill selectedSkill) {

		if (selectedSkill == null || !activeSkills.contains(selectedSkill)) {
			throw new IllegalArgumentException("Invalid selectedSkill : " + selectedSkill.getName());
		}
		if (other == null) {
			throw new IllegalArgumentException("Other Pokemon is null!");
		}

		System.out.println("selected=" + selectedSkill.getName());
		String sfxName = selectedSkill.getSfxName();
		if (sfxName == null || !sfxName.isEmpty()) {
			SFXUtility.playSound(sfxName);
		}

		selectedSkill.applySkillEffect(this, other);
		selectedSkill.setAttackTerrain(currentFightTerrain);
		selectedSkill.setTargetTerrain(other.currentFightTerrain);
		selectedSkill.play();

		IRenderableHolder.addFightObject(selectedSkill);
		while (selectedSkill.isPlaying()) {
			Clock.tick();
		}
		IRenderableHolder.removeFightObject(selectedSkill);

		double damage = ((((2 * level + 10) * selectedSkill.getPower() * getAttack() / other.getDefense() * 0.004) + 2)
				* SWTable.instance.getFactor(selectedSkill.getElement(), other.getPrimaryElement())
				* RandomUtility.randomPercent(85, 100));

		Clock.delay(10);
		processEffectiveness(other, selectedSkill);
		other.getHit();
		Clock.delay(10);
		other.changeHP(-damage);
		if (other.isDead()) {
			other.setKiller(this);
		}
		System.out.println(this.getOwner().getName() + "'s " + this.getName() + " attacked "
				+ other.getOwner().getName() + "'s " + other.getName() + " with " + selectedSkill.getName() + "!"
				+ " Damage dealt : " + StringUtility.formatDouble(damage, 2));
		System.out.printf("%s's HP = %.2f  " + StringUtility.hpBar(other.getCurrentHP() / other.getFullHP()) + "\n",
				other.getName(), other.getCurrentHP());

	}

	private void processEffectiveness(Pokemon other, ActiveSkill selectedSkill) {
		switch (SWTable.instance.getSW(selectedSkill.getElement(), other.getPrimaryElement())) {
		case N:
			SFXUtility.playSound("attack_normal_effective");
			break;
		case S:
			SFXUtility.playSound("attack_super_effective");
			System.out.println("It's super effective!");
			break;
		case W:
			SFXUtility.playSound("attack_not_effective");
			System.out.println("It's not very effective...");
			break;
		case Z:
			SFXUtility.playSound("attack_not_effective");
			System.out.println("It had no effect.");
			break;
		default:
			break;
		}
	}

	public void useItem(Item item) {
		if (item != null && item.getOnPokemonUse() != null) {
			SFXUtility.playSound("potion_use");
			item.getOnPokemonUse().use(this);
		} else {
			System.err.println("unusable item " + item);
		}
	}

	// Comparators

	public static Comparator<Pokemon> bySpeed = (p1, p2) -> Double.compare(p1.nextTurnTime, p2.nextTurnTime);
	public static Comparator<Pokemon> byID = (p1, p2) -> p1.id - p2.id;
	public static Comparator<Pokemon> byHP = (p1, p2) -> Double.compare(p1.currentHP, p2.currentHP);

	/**
	 * Generate <code>paths</code> from <code>range</code> and
	 * <code>filter</code>.
	 */

	public void findBlocksAround(int range, Filter filter) {
		paths.clear();
		findBlocksAroundRecursive(range, new Path(currentFightTerrain), currentFightTerrain, filter);
	}

	/** Called by findBlocksAround() method. */
	private void findBlocksAroundRecursive(int range, Path currentPath, FightTerrain currentFightTerrain,
			Filter filter) {
		if (filter.check(this, currentFightTerrain)) {
			paths.add(currentPath); // adds current pathNode
			if (range >= currentFightTerrain.getType().getMoveCost()) {
				// If range > currentMoveCost , find blocks around it.
				FightTerrain nextFightTerrain;
				for (Direction direction : Direction.values()) {
					nextFightTerrain = currentFightMap.getFightTerrainAt(currentFightTerrain, direction);
					if (nextFightTerrain != null) {
						findBlocksAroundRecursive(range - currentFightTerrain.getType().getMoveCost(),
								new Path(nextFightTerrain, currentPath), nextFightTerrain, filter);
					}
				}
			}
		}
	}

	public HashSet<FightTerrain> getAvaliableFightTerrains() {
		HashSet<FightTerrain> out;
		Function<Path, FightTerrain> getLast = (Path p) -> p.getLast();
		out = (HashSet<FightTerrain>) paths.stream().map(getLast).filter(Objects::nonNull).collect(Collectors.toSet());
		return out;
	}

	/**
	 * Must call <code>findBlocksAround()</code> method before calling this
	 * method.
	 */
	public void shadowBlocks() {
		getAvaliableFightTerrains().parallelStream().forEach(fightTerrain -> fightTerrain.setShadowed(true));
	}

	public Optional<Path> findPathTo(FightTerrain destination) {
		return findPathTo(destination, 100);
	}

	public Optional<Path> findPathTo(FightTerrain destination, int limit) {
		
		/** Inner Class with counter */
		final class PathWithCounter extends Path {
			// TODO Implement Path with Counter (as one class).
			/**
			 * Generated Serial ID
			 */
			private static final long serialVersionUID = 7182452962943995194L;
			short totalCost = 0;

			PathWithCounter(FightTerrain nextFightTerrain, short counter) {
				super(nextFightTerrain);
				this.totalCost = counter;
			}

			PathWithCounter(FightTerrain nextFightTerrain, Path currentPath, short counter) {
				super(nextFightTerrain, currentPath);
				this.totalCost = counter;
			}
		}

		if (getCurrentFightTerrain().equals(destination)) {
			return Optional.of(new Path(destination));
		}

		paths.clear();

		paths.add(new PathWithCounter(getCurrentFightTerrain(), (short) 0));

		boolean duplicatePath;
		int roundsPassed = 0;
		short index = 0, lastPathIterCost = 0;
		int nextTerrainCost;
		Path lastPathIter;
		FightTerrain nextTerrain;
		Filter moveFilter = new MoveNoOverlapFilter();

		while (roundsPassed < limit) {
			if (index >= paths.size()) {
				System.err.println("Pokemon.findPath() : Failed to find Path");
				return Optional.empty();
			}
			lastPathIter = paths.get(index);
			lastPathIterCost = ((PathWithCounter) lastPathIter).totalCost;
			for (Direction direction : Direction.values()) {
				nextTerrain = currentFightMap.getFightTerrainAt(lastPathIter.getLast(), direction);
				if (nextTerrain != null && moveFilter.check(this, nextTerrain)) {
					// nextTerrain is movable!
					nextTerrainCost = nextTerrain.getType().getMoveCost();
					duplicatePath = false;
					Iterator<Path> pathIter = paths.iterator();
					while (pathIter.hasNext()) {
						Path existingPath = pathIter.next();
						PathWithCounter existingPathWithCounter = (PathWithCounter) existingPath;
						if (existingPath.getLast().equals(nextTerrain)) {
							if (existingPathWithCounter.totalCost <= lastPathIterCost + nextTerrainCost) {
								// There is a duplicate element in paths.
								duplicatePath = true;
								break;
							} else {
								// beware concurrent error
								pathIter.remove();
								break;
							}
						}
					}
					if (!duplicatePath) {
						paths.add(new PathWithCounter(nextTerrain, lastPathIter,
								(short) (lastPathIterCost + nextTerrainCost)));
						if (nextTerrain.equals(destination)) {
							// We have found the solution!
							return Optional.of(paths.get(paths.size() - 1));
						}
					}
				}
			} // end for direction
			roundsPassed++;
			index++;
		} // end of while loop

		System.err.println("Pokemon.findPath() : Failed to find Path within internal limit.");
		return null;
	} // end of Pokemon.findPath()

	// ActiveSkill methods

	public void addActiveSkill(ActiveSkill newActiveSkill) {
		if (activeSkills.size() < MAX_ACTIVE_SKILLS) {
			activeSkills.add(newActiveSkill);
		} else {
			System.err.println("Maximum no. of activeSkills for " + getName());
		}
	}

	public void addActiveSkill(String activeSkillName) {
		if (activeSkills.size() < MAX_ACTIVE_SKILLS) {
			activeSkills.add(ActiveSkill.getActiveSkill(activeSkillName));
		} else {
			System.err.println("Maximum no. of activeSkills for " + getName());
		}
	}

	public void removeActiveSkill(ActiveSkill activeSkill) {
		if (activeSkills.contains(activeSkill)) {
			activeSkills.remove(activeSkill);
		}
	}

	public void removeActiveSkill(String activeSkillName) {
		if (activeSkills.contains(ActiveSkill.getActiveSkill(activeSkillName))) {
			activeSkills.remove(ActiveSkill.getActiveSkill(activeSkillName));
		}
	}

	public void calculateNextTurnTime() {
		nextTurnTime += (1.0 / stats.get("speed").current);
	}

	public void sortPaths() {
		Collections.shuffle(paths);
		Collections.sort(paths);
		Collections.reverse(paths);
	}

	public static Optional<MoveType> toMoveType(String moveTypeString) {
		return Stream.of(MoveType.values()).filter(mt -> mt.toString().equalsIgnoreCase(moveTypeString)).findAny();
	}

	// Pseudo Animations

	private double lastHpBuffer, hpChangeBuffer, lastExpBuffer, expChangeBuffer;

	private static PseudoAnimation<Pokemon> changeHP = new PseudoAnimation<Pokemon>(120, 0) {
		@Override
		public void update() {
			if (delayCounter == frameDelay) {
				currentFrame++;
				double delta = target.hpChangeBuffer / 120.0;
				if (Math.abs(delta) > target.getFullHP() * 0.02) {
					delta = target.getFullHP() * 0.02 * (Math.abs(delta) / delta);
				}
				target.currentHP = target.lastHpBuffer + currentFrame * delta;
				if (target.currentHP < 0) {
					target.currentHP = 0;
					stop();
				} else if (target.currentHP > target.getFullHP()) {
					target.currentHP = target.getFullHP();
					stop();
				} else if (currentFrame == amountOfFrame) {
					stop();
				}
				delayCounter = 0;
			} else {
				delayCounter++;
			}
		}
	};

	private static PseudoAnimation<Pokemon> increaseExp = new PseudoAnimation<Pokemon>(0, 0) {
		@Override
		public void update() {
			if (delayCounter == frameDelay) {
				double expGap = target.nextExpRequired - target.lastExpRequired;
				double delta = expGap * 0.01;
				if (target.nextExpRequired - target.currentExp < delta) {
					delta = target.nextExpRequired - target.currentExp;
				}
				if (target.expChangeBuffer < delta) {
					target.addExpAndTryLevelUp(target.expChangeBuffer);
					stop();
				}
				target.addExpAndTryLevelUp(delta);
				target.expChangeBuffer -= delta;
				delayCounter = 0;
			} else {
				delayCounter++;
			}
		}
	};

	private static PseudoAnimation<Pokemon> blink = new PseudoAnimation<Pokemon>(6, 8) {
		@Override
		public void update() {
			if (delayCounter == frameDelay) {
				currentFrame++;
				if (currentFrame % 2 == 1) {
					target.hide();
				} else {
					target.show();
				}
				if (currentFrame == amountOfFrame) {
					stop();
				}
				delayCounter = 0;
			} else {
				delayCounter++;
			}
		}
	};

	// Graphics

	@Override
	public void draw() {
		DrawingUtility.drawPokemon(this);
	}

	@Override
	public int getDepth() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean isVisible() {
		return visible;
	}

	@Override
	public void setVisible(boolean visible) {
		this.visible = visible;
	}

	@Override
	public void hide() {
		visible = false;
		IRenderableHolder.removeFightObject(this);
	}

	@Override
	public void show() {
		IRenderableHolder.addFightObject(this);
		visible = true;
	}

	public void loadImage() {
		File file = new File(imageFileName);
		image = new Image(file.toURI().toString());
		file = new File("load\\img\\pokemon\\icon\\" + getName() + ".png");
		System.out.println(file);
		try {
			icon = new Image(file.toURI().toString());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// Getters and Setters

	public void resetHP() {
		currentHP = ((HPStat) stats.get("hp")).getFull();
	}

	public void setHp(double hp) {
		if (Double.compare(hp, 0) < 0) {
			this.currentHP = 0;
		} else {
			this.currentHP = hp;
		}
	}

	public void changeHP(double change) {
		if (change + currentHP > getFullHP()) {
			change = getFullHP() - currentHP;
		} else if (change + currentHP < 0) {
			change = -currentHP;
		}
		hpChangeBuffer = change;
		lastHpBuffer = currentHP;
		changeHP.setTarget(this);
		changeHP.play();
		while (changeHP.isPlaying()) {
			Clock.tick();
		}
		// currentHP = currentHP + change < 0 ? 0 : currentHP + change;
	}

	public void getHit() {
		blink.setTarget(this);
		blink.play();
		while (blink.isPlaying()) {
			Clock.tick();
		}
	}

	public boolean isDead() {
		return Double.compare(currentHP, 0) <= 0;
	}

	public final int getID() {
		return id;
	}

	public final Player getOwner() {
		return owner;
	}

	public void changeNextTurnTime(double change) {
		this.nextTurnTime += change;
	}

	public void resetNextTurnTime() {
		this.nextTurnTime = 0;
	}

	public final double getNextTurnTime() {
		return nextTurnTime;
	}

	public final Map<String, Stat> getStats() {
		return stats;
	}

	public final int getAttack() {
		return stats.get("attack").current;
	}

	public final int getDefense() {
		return stats.get("defense").current;
	}

	public final int getSpeed() {
		return stats.get("speed").current;
	}

	public final double getCurrentHP() {
		return currentHP;
	}

	public final double getFullHP() {
		return ((HPStat) stats.get("hp")).getFull();
	}

	public final int getLevel() {
		return level;
	}

	private void updateExpRequired() {
		nextExpRequired = levelingRate.getRequiredExperience(level + 1);
		lastExpRequired = levelingRate.getRequiredExperience(level);
	}

	public final void setLevel(int level) {
		if (level < MIN_LEVEL || level > MAX_LEVEL) {
			throw new IllegalArgumentException(
					"Pokemon.setLevel() : Illegal level for Pokemon " + this.getName() + ", level=" + level);
		}
		this.level = level;
		stats.values().forEach(s -> s.calculateCurrent(level));
		updateExpRequired();
		this.currentExp = lastExpRequired;
		resetHP();
	}

	public final void levelUp() {
		if (level == MAX_LEVEL) {
			return;
		}
		SFXUtility.playSound("pokemon_exp_bar_full");
		System.out.println(getName() + " level up!");
		level++;
		stats.values().forEach(s -> s.calculateCurrent(level));
		updateExpRequired();
		resetHP();
	}

	public void tryLevelUp() {
		while (currentExp >= nextExpRequired) {
			levelUp();
		}
	}

	public final void addExpAndTryLevelUp(double change) {
		currentExp += change; // TODO
		tryLevelUp();
	}

	public final void addExp(double change) {
		SFXUtility.playSound("exp_increase");
		expChangeBuffer = change;
		increaseExp.setTarget(this);
		increaseExp.play();
		while (increaseExp.isPlaying()) {
			Clock.tick();
		}
		SFXUtility.stopSound("exp_increase");
	}

	public final double getExp() {
		return currentExp;
	}

	public final List<ActiveSkill> getActiveSkills() {
		return activeSkills;
	}

	public final List<PassiveSkill> getPassiveSkills() {
		return passiveSkills;
	}

	public void setOwner(Player owner) {
		this.owner = owner;
	}

	public final ArrayList<Path> getPaths() {
		return paths;
	}

	public final FightMap getCurrentFightMap() {
		if (currentFightMap == null) {
			System.err.println("WARNING : Current FightMap is not set for " + getName());
		}
		return currentFightMap;
	}

	public final void setCurrentFightMap(FightMap currentFightMap) {
		this.currentFightMap = currentFightMap;
	}

	public final FightTerrain getCurrentFightTerrain() {
		return currentFightTerrain;
	}

	public void setImageFileLocation(String imageFileName) {
		this.imageFileName = imageFileName;
	}

	public void setDefaultImageFileLocation() {
		setImageFileLocation(DEFAULT_IMAGE_FILE_LOCATION + "/" + this.getName() + ".png");
	}

	public final NonVolatileStatus getStatus() {
		return status;
	}

	public final void setStatus(NonVolatileStatus status) {
		this.status = status;
	}

	public final Pokemon getKiller() {
		return killer;
	}

	public final void setKiller(Pokemon killer) {
		this.killer = killer;
	}

	public final double getLastExpRequired() {
		return lastExpRequired;
	}

	public final double getNextExpRequired() {
		return nextExpRequired;
	}

	public final double getCurrentExp() {
		return currentExp;
	}

}
