package logic_fight.character.pokemon;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import audio.SFXUtility;
import graphic.DrawingUtility;
import graphic.GameScreen;
import graphic.IRenderable;
import graphic.IRenderableHolder;
import graphic.PsuedoAnimation;
import javafx.scene.image.Image;
import logic_fight.character.HPStat;
import logic_fight.character.PassiveSkill;
import logic_fight.character.SWTable;
import logic_fight.character.Stat;
import logic_fight.character.activeSkill.ActiveSkill;
import logic_fight.filters.Filter;
import logic_fight.filters.MoveNoOverlapFilter;
import logic_fight.player.Player;
import logic_fight.terrain.FightMap;
import logic_fight.terrain.FightTerrain;
import logic_fight.terrain.Path;
import logic_fight.terrain.FightMap.Direction;
import utility.Clock;
import utility.Pokedex;
import utility.RandomUtility;
import utility.StringUtility;

public class Pokemon extends AbstractPokemon implements Cloneable, IRenderable {

	// Constants and Variables

	private static final String DEFAULT_IMAGE_FILE_LOCATION = "load/img/pokemon";
	public static final int MAX_ACTIVE_SKILLS = 4;

	private double currentHP, nextTurnTime;
	private Player owner;
	private List<ActiveSkill> activeSkills = new ArrayList<ActiveSkill>();
	private List<PassiveSkill> passiveSkills = new ArrayList<PassiveSkill>();
	private Stat attack, defense, speed;
	private HPStat hp;
	private Map<String, Stat> stats = new HashMap<String, Stat>();
	/** Individual value */
	private Status status = Status.NORMAL;
	private Pokemon killer;
	private boolean visible = true;
	private boolean showSkillMenu = false;

	/**
	 * Holds avaliable paths to move generated by
	 * <code>findBlocksAround()</code>.
	 */
	private ArrayList<Path> paths = new ArrayList<Path>();
	private FightMap currentFightMap = null;
	private FightTerrain currentFightTerrain = null;

	private int level;
	private double currentExp;
	private double lastExpRequired;
	private double nextExpRequired;
	
	//PsuedoAnimation (may be static in future)
	private PsuedoAnimation changeHP = new PsuedoAnimation(20, 3) {
		
		@Override
		public void update() {
			// TODO Auto-generated method stub
			if (delayCounter == frameDelay) {
				System.out.println("(Pokemon 83 :)reach");
				currentFrame++;
				System.out.println("CurrentHp" + currentHP);
				System.out.println("lastHp" + lastHPBuffer);
				System.out.println("Frame" + currentFrame);
				System.out.println("HpChange" + HPChangeBuffer);
				currentHP = lastHPBuffer + (currentFrame * HPChangeBuffer / 20.0);
				if (currentHP < 0) {
					currentHP = 0;
					stop();
				}
				else if (currentHP > getFullHP()) {
					currentHP = getFullHP();
					stop();
				}
				else if (currentFrame == amountOfFrame) {
					stop();
				}
				delayCounter = 0;
			}
			else{
				delayCounter++;
			}
		}
	};
	private PsuedoAnimation increaseEXP = new PsuedoAnimation(0, 0) {
		
		@Override
		public void update() {
			// TODO Auto-generated method stub
			
		}
	};
	private double lastHPBuffer, EXPBuffer, HPChangeBuffer;

	// Enums and inner classes

	/** This inner class is used to hold pokemon stats (base and current). */
	// @Deprecated
	// public class Stat implements Cloneable {
	// public double attackStat, defenceStat, speed, fullHP;
	//
	// @Override
	// public Object clone() throws CloneNotSupportedException {
	// return (Stat) super.clone();
	// }
	// }

	/** Type of relocation on <code>fightMap</code>. */
	public static enum MoveType {
		FLY, SWIM, WALK;

		public boolean check(FightTerrain ft) {
			switch (ft.getType()) {
			case WATER:
				return this.equals(SWIM) || this.equals(FLY);
			case ROCK:
			case TREE:
				return this.equals(FLY);
			case GRASS:
			case GROUND:
			default:
				return true;
			}
		}
	}

	// Constructors

	public Pokemon(PokemonTemplate pokemonTemplate, int level) {
		Objects.requireNonNull(pokemonTemplate, "pokemonTemplate Required in Pokemon Constructor");
		id = pokemonTemplate.id;
		this.level = level;

		attack = new Stat(pokemonTemplate.getBaseAttack(), level);
		defense = new Stat(pokemonTemplate.getBaseDefense(), level);
		speed = new Stat(pokemonTemplate.getBaseSpeed(), level);
		hp = new HPStat(pokemonTemplate.getBaseHP(), level);

		moveRange = pokemonTemplate.moveRange;
		attackRange = pokemonTemplate.attackRange;
		moveType = pokemonTemplate.moveType;

		stats.put("attack", attack);
		stats.put("defense", defense);
		stats.put("speed", speed);
		stats.put("hp", hp);

		primaryElement = pokemonTemplate.primaryElement;
		secondaryElement = pokemonTemplate.secondaryElement;
		levelingRate = pokemonTemplate.levelingRate;
		expYield = pokemonTemplate.expYield;

		updateExpRequired();
		currentExp = levelingRate.getRequiredExperience(level);

		nextTurnTime = 0;
		calculateNextTurnTime();
		resetHP();
		setImageFileLocation();
	}

	public Pokemon(PokemonTemplate pokemonTemplate, int level, Player owner) {
		this(pokemonTemplate, level);
		owner.addPokemon(this);
	}

	// public Pokemon(int id, int attackStat, int defenceStat, int speed, int
	// hp, int moveRange, int attackRange,
	// MoveType moveType) {
	// this.id = id;
	// attack = new Stat(attackStat, level);
	// defense = new Stat(defenceStat, level);
	// this.hp = new HPStat(hp, level);
	// this.speed = new Stat(speed, level);
	// this.moveRange = moveRange;
	// this.attackRange = attackRange;
	// this.moveType = moveType;
	// stats = Arrays.asList(attack, defense, this.speed, this.hp);
	// nextTurnTime = 0;
	// calculateNextTurnTime();
	// resetHP();
	// setImageFileLocation();
	// }
	//
	// public Pokemon(int id, int attackStat, int defenceStat, int speed, int
	// hp, int moveRange, int attackRange,
	// MoveType moveType, Player owner) {
	// this(id, attackStat, defenceStat, speed, hp, moveRange, attackRange,
	// moveType);
	// this.owner = owner;
	// owner.addPokemon(this);
	// }
	//
	// /**
	// * Load arguments to <code>Pokemon</code> by <code>String[]</code>. </br>
	// * Usage : id attack defence speed fullHP moveRange attackRange moveType.
	// *
	// * @param args
	// * String of arguments.
	// */
	// public Pokemon(String[] args) {
	// id = Integer.parseInt(args[0]);
	// attack = new Stat(Integer.parseInt(args[1]), level);
	// defense = new Stat(Integer.parseInt(args[2]), level);
	// speed = new Stat(Integer.parseInt(args[3]), level);
	// hp = new HPStat(Integer.parseInt(args[4]), level);
	// moveRange = Integer.parseInt(args[5]);
	// attackRange = Integer.parseInt(args[6]);
	// moveType = toMoveType(args[7]).orElse(MoveType.WALK);
	// stats = Arrays.asList(attack, defense, this.speed, this.hp);
	// nextTurnTime = 0;
	// calculateNextTurnTime();
	// resetHP();
	// setImageFileLocation();
	// }

	@Override
	public String toString() {
		return "Pokemon " + this.getName() + " LV." + this.getLevel();
	}

	public void showStats() {
		System.out.println("name : " + getName());
		System.out.println("level : " + level);
		System.out.println(" - attack" + attack);
		System.out.println(" - defense" + defense);
		System.out.println(" - speed" + speed);
		System.out.println(" - hp" + hp);
	}

	/** Use to reset pokemon before entering fight */
	public void enterFight() {
		stats.values().forEach(st -> st.resetStage());
		killer = null;
	}

	// move and attack

	/**
	 * Use to relocate this <code>Pokemon</code> on <code>fightMap</code>.
	 * <code>currentFightTerrain</code> will be automatically generated. Does
	 * not use <code>Filter.check()</code>.
	 * 
	 * @param x
	 *            position
	 * @param y
	 *            position
	 */
	public void move(int x, int y) {
		Objects.requireNonNull(currentFightMap, "Pokemon.move() : [ID=" + id + "].currentFightMap not set");
		if (!currentFightMap.outOfMap(x, y)) {
			this.currentFightTerrain = currentFightMap.getFightTerrainAt(x, y);
		} else {
			this.currentFightTerrain = null;
		}
	}

	public void move(FightTerrain fightTerrain) {
		this.currentFightTerrain = fightTerrain;
	}

	public void attack(Pokemon other, ActiveSkill selectedSkill) {
		if (selectedSkill == null || !activeSkills.contains(selectedSkill)) {
			throw new IllegalArgumentException("Invalid selectedSkill : " + selectedSkill.getName());
		}
		if (other == null) {
			throw new IllegalArgumentException("Other Pokemon is null!");
		}
		double damage = ((((2 * level + 10) * selectedSkill.getPower() * attack.current / other.defense.current)
				* 0.004) + 2) * SWTable.instance.getFactor(selectedSkill.getElement(), other.getPrimaryElement())
				* RandomUtility.randomPercent(85, 100);
		other.changeHP(-damage);
		if (other.isDead()) {
			other.setKiller(this);
		}
		System.out.println(this.getOwner().getName() + "'s " + this.getName() + " attacked "
				+ other.getOwner().getName() + "'s " + other.getName() + " with " + selectedSkill.getName() + "!"
				+ " Damage dealt : " + StringUtility.formatDouble(damage, 2));
		System.out.printf("%s's HP = %.2f  " + StringUtility.hpBar(other.getCurrentHP() / other.getFullHP()) + "\n",
				other.getName(), other.getCurrentHP());
		processEffectiveness(other, selectedSkill);

		selectedSkill.applySkillEffect(this, other);
		selectedSkill.setAttackTerrain(currentFightTerrain);
		selectedSkill.setTargetTerrain(other.currentFightTerrain);
		selectedSkill.play();

		IRenderableHolder.addFightObject(selectedSkill);
		while (selectedSkill.isPlaying()) {
			Clock.tick();
		}
		IRenderableHolder.removeFightObject(selectedSkill);
	}

	private void processEffectiveness(Pokemon other, ActiveSkill selectedSkill) {
		switch (SWTable.instance.getSW(selectedSkill.getElement(), other.getPrimaryElement())) {
		case N:
			break;
		case S:
			SFXUtility.playSound("attack_super_effective");
			System.out.println("It's super effective!");
			break;
		case W:
			SFXUtility.playSound("attack_not_effective");
			System.out.println("It's not very effective...");
			break;
		case Z:
			break;
		default:
			break;
		}
	}

	public Predicate<Pokemon> isEnemy = (Pokemon other) -> !other.getOwner().equals(this.getOwner());
	public Predicate<Pokemon> isFriendly = (Pokemon other) -> other.getOwner().equals(this.getOwner());

	// Comparators

	public static Comparator<Pokemon> bySpeed = (p1, p2) -> Double.compare(p1.nextTurnTime, p2.nextTurnTime);
	public static Comparator<Pokemon> byID = (p1, p2) -> p1.id - p2.id;
	public static Comparator<Pokemon> byHP = (p1, p2) -> Double.compare(p1.currentHP, p2.currentHP);

	// Clone

	@Override
	public Object clone() throws CloneNotSupportedException {
		return (Pokemon) super.clone();
	}

	/**
	 * Generate <code>paths</code> from <code>range</code> and
	 * <code>filter</code>.
	 */

	public void findBlocksAround(int range, Filter filter) {
		paths.clear();
		findBlocksAroundRecursive(range, new Path(currentFightTerrain), currentFightTerrain, filter);
	}

	/** Called by findBlocksAround() method. */
	private void findBlocksAroundRecursive(int range, Path currentPath, FightTerrain currentFightTerrain,
			Filter filter) {
		if (filter.check(this, currentFightTerrain)) {
			paths.add(currentPath); // adds current pathNode
			if (range >= currentFightTerrain.getType().getMoveCost()) {
				// If range > currentMoveCost , find blocks around it.
				FightTerrain nextFightTerrain;
				for (Direction direction : Direction.values()) {
					nextFightTerrain = currentFightMap.getFightTerrainAt(currentFightTerrain, direction);
					if (nextFightTerrain != null) {
						findBlocksAroundRecursive(range - currentFightTerrain.getType().getMoveCost(),
								new Path(nextFightTerrain, currentPath), nextFightTerrain, filter);
					}
				}
			}
		}
	}

	public HashSet<FightTerrain> getAvaliableFightTerrains() {
		HashSet<FightTerrain> out;
		Function<Path, FightTerrain> getLast = (Path p) -> p.getLast();
		out = (HashSet<FightTerrain>) paths.stream().map(getLast).filter(Objects::nonNull).collect(Collectors.toSet());
		return out;
	}

	/**
	 * Must call <code>findBlocksAround()</code> method before calling this
	 * method.
	 */
	public void shadowBlocks() {
		getAvaliableFightTerrains().parallelStream().forEach(fightTerrain -> fightTerrain.setShadowed(true));
	}

	public Optional<Path> findPathTo(FightTerrain destination) {
		return findPathTo(destination, 100);
	}

	public Optional<Path> findPathTo(FightTerrain destination, int limit) {

		/** Inner Class with counter */
		final class PathWithCounter extends Path {
			// TODO Implement Path with Counter (as one class).
			/**
			 * Generated Serial ID
			 */
			private static final long serialVersionUID = 7182452962943995194L;
			short totalCost = 0;

			PathWithCounter(FightTerrain nextFightTerrain, short counter) {
				super(nextFightTerrain);
				this.totalCost = counter;
			}

			PathWithCounter(FightTerrain nextFightTerrain, Path currentPath, short counter) {
				super(nextFightTerrain, currentPath);
				this.totalCost = counter;
			}
		}

		if (getCurrentFightTerrain().equals(destination)) {
			return Optional.of(new Path(destination));
		}

		paths.clear();

		paths.add(new PathWithCounter(getCurrentFightTerrain(), (short) 0));

		boolean duplicatePath;
		int roundsPassed = 0;
		short index = 0, lastPathIterCost = 0;
		int nextTerrainCost;
		Path lastPathIter;
		FightTerrain nextTerrain;
		Filter moveFilter = new MoveNoOverlapFilter();

		while (roundsPassed < limit) {
			if (index >= paths.size()) {
				System.err.println("Pokemon.findPath() : Failed to find Path");
				return Optional.empty();
			}
			lastPathIter = paths.get(index);
			lastPathIterCost = ((PathWithCounter) lastPathIter).totalCost;
			for (Direction direction : Direction.values()) {
				nextTerrain = currentFightMap.getFightTerrainAt(lastPathIter.getLast(), direction);
				if (nextTerrain != null && moveFilter.check(this, nextTerrain)) {
					// nextTerrain is movable!
					nextTerrainCost = nextTerrain.getType().getMoveCost();
					duplicatePath = false;
					Iterator<Path> pathIter = paths.iterator();
					while (pathIter.hasNext()) {
						Path existingPath = pathIter.next();
						PathWithCounter existingPathWithCounter = (PathWithCounter) existingPath;
						if (existingPath.getLast().equals(nextTerrain)) {
							if (existingPathWithCounter.totalCost <= lastPathIterCost + nextTerrainCost) {
								// There is a duplicate element in paths.
								duplicatePath = true;
								break;
							} else {
								// beware concurrent error
								pathIter.remove();
								break;
							}
						}
					}
					if (!duplicatePath) {
						paths.add(new PathWithCounter(nextTerrain, lastPathIter,
								(short) (lastPathIterCost + nextTerrainCost)));
						if (nextTerrain.equals(destination)) {
							// We have found the solution!
							return Optional.of(paths.get(paths.size() - 1));
						}
					}
				}
			} // end for direction
			roundsPassed++;
			index++;
		} // end of while loop

		System.err.println("Pokemon.findPath() : Failed to find Path within internal limit.");
		return null;
	} // end of Pokemon.findPath()

	// ActiveSkill methods

	public void addActiveSkill(ActiveSkill newActiveSkill) {
		if (activeSkills.size() < MAX_ACTIVE_SKILLS) {
			activeSkills.add(newActiveSkill);
		} else {
			System.err.println("Maximum no. of activeSkills for " + getName());
		}
	}

	public void addActiveSkill(String activeSkillName) {
		if (activeSkills.size() < MAX_ACTIVE_SKILLS) {
			activeSkills.add(ActiveSkill.getActiveSkill(activeSkillName));
		} else {
			System.err.println("Maximum no. of activeSkills for " + getName());
		}
	}

	public void removeActiveSkill(ActiveSkill activeSkill) {
		if (activeSkills.contains(activeSkill)) {
			activeSkills.remove(activeSkill);
		}
	}

	public void removeActiveSkill(String activeSkillName) {
		if (activeSkills.contains(ActiveSkill.getActiveSkill(activeSkillName))) {
			activeSkills.remove(ActiveSkill.getActiveSkill(activeSkillName));
		}
	}

	public void calculateNextTurnTime() {
		nextTurnTime += (1.0 / speed.current);
	}

	public void sortPaths() {
		Collections.shuffle(paths);
		Collections.sort(paths);
		Collections.reverse(paths);
	}

	public static Optional<MoveType> toMoveType(String moveTypeString) {
		return Stream.of(MoveType.values()).filter(mt -> mt.toString().equalsIgnoreCase(moveTypeString)).findAny();
	}

	// Graphics

	@Override
	public void draw() {
		DrawingUtility.drawPokemon(this);
	}

	@Override
	public int getDepth() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean isVisible() {
		// TODO Auto-generated method stub
		return visible;
	}

	@Override
	public void setVisible(boolean visible) {
		// TODO Auto-generated method stub
		this.visible = visible;
	}

	@Override
	public void hide() {
		// TODO Auto-generated method stub
		visible = false;
		IRenderableHolder.removeWorldObject(this);
	}

	@Override
	public void show() {
		// TODO Auto-generated method stub
		IRenderableHolder.addWorldObject(this);
		visible = true;
	}

	public void loadImage() {
		File file = new File(imageFileName);
		image = new Image(file.toURI().toString());
		file = new File("load\\img\\pokemon\\icon\\" + getName() + ".png");
		try {
			icon = new Image(file.toURI().toString());			
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}
	}

	// Getters and Setters

	public void resetHP() {
		currentHP = hp.getFull();
	}

	public double getHP() {
		return currentHP;
	}

	public void setHp(double hp) {
		if (Double.compare(hp, 0) < 0) {
			this.currentHP = 0;
		} else {
			this.currentHP = hp;
		}
	}

	public void changeHP(double change) {
		HPChangeBuffer = change;
		lastHPBuffer = currentHP;
		changeHP.play();
		while (changeHP.isPlaying()) {
			Clock.tick();
		}
		//currentHP = currentHP + change < 0 ? 0 : currentHP + change;
	}

	public boolean isDead() {
		return Double.compare(currentHP, 0) <= 0;
	}

	public final int getID() {
		return id;
	}

	public String getName() {
		return Pokedex.getPokemonName(id);
	}

	public final Player getOwner() {
		return owner;
	}

	public void changeNextTurnTime(double change) {
		this.nextTurnTime += change;
	}

	public final double getNextTurnTime() {
		return nextTurnTime;
	}

	public final Map<String, Stat> getStats() {
		return stats;
	}

	public final int getAttack() {
		return attack.current;
	}

	public final int getDefense() {
		return defense.current;
	}

	public final int getSpeed() {
		return speed.current;
	}

	public final double getCurrentHP() {
		return currentHP;
	}

	public final double getFullHP() {
		return hp.getFull();
	}

	public final int getLevel() {
		return level;
	}

	private void updateExpRequired() {
		nextExpRequired = levelingRate.getRequiredExperience(level + 1);
		lastExpRequired = levelingRate.getRequiredExperience(level);
	}

	public final void setLevel(int level) {
		this.level = level;
		stats.values().forEach(s -> s.calculateCurrent(level));
		updateExpRequired();
		this.currentExp = lastExpRequired;
		resetHP();
	}

	public final void levelUp() {
		System.out.println(getName() + " level up!");
		level++;
		stats.values().forEach(s -> s.calculateCurrent(level));
		updateExpRequired();
		resetHP();
	}

	public void tryLevelUp() {
		while (currentExp >= nextExpRequired) {
			levelUp();
		}
	}

	public final void addExpAndTryLevelUp(double change) {
		currentExp += change;
		tryLevelUp();
	}

	public final double getExp() {
		return currentExp;
	}

	public final List<ActiveSkill> getActiveSkills() {
		return activeSkills;
	}

	public final List<PassiveSkill> getPassiveSkills() {
		return passiveSkills;
	}

	public void setOwner(Player owner) {
		this.owner = owner;
	}

	public final ArrayList<Path> getPaths() {
		return paths;
	}

	public final FightMap getCurrentFightMap() {
		return currentFightMap;
	}

	public final void setCurrentFightMap(FightMap currentFightMap) {
		this.currentFightMap = currentFightMap;
	}

	public final FightTerrain getCurrentFightTerrain() {
		return currentFightTerrain;
	}

	public void setImageFileLocation(String imageFileName) {
		this.imageFileName = imageFileName;
	}

	public void setImageFileLocation() {
		setImageFileLocation(DEFAULT_IMAGE_FILE_LOCATION + "/" + this.getName() + ".png");
	}

	public static final String getDefaultImageFileLocation() {
		return DEFAULT_IMAGE_FILE_LOCATION;
	}

	public final Status getStatus() {
		return status;
	}

	public final void setStatus(Status status) {
		this.status = status;
	}

	public final Pokemon getKiller() {
		return killer;
	}

	public final void setKiller(Pokemon killer) {
		this.killer = killer;
	}

	public final double getLastExpRequired() {
		return lastExpRequired;
	}

	public final double getNextExpRequired() {
		return nextExpRequired;
	}

	public final double getCurrentExp() {
		return currentExp;
	}
	
	public boolean isShowSkillMenu() {
		return showSkillMenu;
	}
	
	public void setShowSkillMenu(boolean showSkillMenu) {
		this.showSkillMenu = showSkillMenu;
	}

}
