package logic_fight.terrain;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import graphic.DrawingUtility;
import graphic.IRenderable;
import graphic.IRenderableHolder;
import logic_fight.character.pokemon.Pokemon;
import logic_fight.filters.Filter;
import logic_fight.filters.MoveFilter;
import logic_fight.player.HumanPlayer;
import utility.InputUtility;

public class FightMap implements IRenderable {

	public static final int MAX_SIZE_X = 20;
	public static final int MAX_SIZE_Y = 20;
	public static final int BLOCK_SIZE = 40;
	private static int originX, originY;
	private static int zoomLevel;
	private int sizeX, sizeY;
	private FightTerrain[][] map;
	private ArrayList<Pokemon> pokemonsOnMap = new ArrayList<Pokemon>();
	private ArrayList<Pokemon> playerPokemonsOnMap = new ArrayList<Pokemon>(3);
	private ArrayList<Pokemon> enemyPokemonsOnMap = new ArrayList<Pokemon>(3);
	private boolean visible = true;

	public static enum Direction {
		UP(0, -1), LEFT(-1, 0), DOWN(0, 1), RIGHT(1, 0);

		public int x, y;

		Direction(int x, int y) {
			this.x = x;
			this.y = y;
		}
	}

	public FightMap(int sizeX, int sizeY) {
		if (sizeX < 0) {
			sizeX = 0;
		} else if (sizeX > MAX_SIZE_X) {
			sizeX = MAX_SIZE_X;
		}
		if (sizeY < 0) {
			sizeY = 0;
		} else if (sizeY > MAX_SIZE_Y) {
			sizeY = MAX_SIZE_Y;
		}
		this.sizeX = sizeX;
		this.sizeY = sizeY;
		map = new FightTerrain[sizeY][sizeX];
		originX = 0;
		originY = 0;
		zoomLevel = 0;
	}

	public FightMap(FightTerrain[][] ft) {
		map = ft;
		sizeX = map[0].length;
		sizeY = map.length;
		originX = 10;
		originY = 10;
		zoomLevel = 0;
	}

	/** Sort by Speed. Used in calculation of Turn Time and Queue. */
	public void sortPokemons() {
		Collections.sort(pokemonsOnMap, Pokemon.bySpeed);
	}

	public FightTerrain[][] getMap() {
		return map;
	}

	public void setMap(FightTerrain[][] map) {
		this.map = map;
	}

	public FightTerrain getFightTerrainAt(int x, int y) {
		if (outOfMap(x, y)) {
			return null;
		}
		return map[y][x];
	}

	public FightTerrain getFightTerrainAt(FightTerrain paramFT, Direction d) {
		return getFightTerrainAt(paramFT.getX() + d.x, paramFT.getY() + d.y);
	}

	public void setFightTerrainAt(int x, int y, FightTerrain fightTerrain) {
		map[y][x] = fightTerrain;
	}

	public Optional<Pokemon> getPokemonAt(int x, int y) {
		for (Pokemon pokemon : pokemonsOnMap) {
			if (pokemon.getCurrentFightTerrain().getX() == x && pokemon.getCurrentFightTerrain().getY() == y) {
				return Optional.of(pokemon);
			}
		}
		return Optional.empty();
	}

	public Optional<Pokemon> getPokemonAt(FightTerrain fightTerrain) {
		return getPokemonAt(fightTerrain.getX(), fightTerrain.getY());
	}

	public boolean outOfMap(int x, int y) {
		if (x < 0 || x >= this.sizeX || y < 0 || y >= this.sizeY) {
			return true;
		} else {
			return false;
		}
	}

	public void draw() {
		double x = InputUtility.getMouseX(), y = InputUtility.getMouseY();
		if (0 <= x && x <= 319 && 0 <= y && y <= 239) {
			getFightTerrainAt((int) Math.floor(x / FightTerrain.IMG_SIZE_X),
					(int) Math.floor(y / FightTerrain.IMG_SIZE_Y)).setCursor(true);
		}
		DrawingUtility.drawFightMap(this);
	}

	@Override
	public int getDepth() {
		// TODO Auto-generated method stub
		return 0;
	}
	
	@Override
	public boolean isVisible() {
		// TODO Auto-generated method stub
		return visible;
	}
	
	@Override
	public void setVisible(boolean visible) {
		// TODO Auto-generated method stub
		this.visible = visible;
	}
	
	@Override
	public void hide() {
		// TODO Auto-generated method stub
		visible = false;
		IRenderableHolder.removeWorldObject(this);
	}
	
	@Override
	public void show() {
		// TODO Auto-generated method stub
		IRenderableHolder.addWorldObject(this);
		visible = true;
	}

	public final int getSizeX() {
		return sizeX;
	}

	public final int getSizeY() {
		return sizeY;
	}

	/** @return Unmodifiable List of Pokemons on Map. */
	public final List<Pokemon> getPokemonsOnMap() {
		return Collections.unmodifiableList(pokemonsOnMap);
	}

	/**
	 * Use this to add Pokemon to map. Returns true if pokemon can be placed and
	 * places the pokemon.
	 */
	public boolean addPokemonToMap(int x, int y, Pokemon pokemon) {
		Filter canBePlacedFilter = new MoveFilter();
		if (!outOfMap(x, y) && pokemon != null && canBePlacedFilter.check(pokemon, this, map[y][x])
				&& !this.getPokemonAt(x, y).isPresent()) {
			// Can be Added!
			pokemon.setCurrentFightMap(this);
			pokemon.move(x, y);
			pokemonsOnMap.add(pokemon);
			if (pokemon.getOwner() instanceof HumanPlayer) {
				playerPokemonsOnMap.add(pokemon);
			}
			else{
				enemyPokemonsOnMap.add(pokemon);
			}
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Use this to remove Pokemon from map. Returns true if pokemon is on map.
	 */
	public boolean removePokemonFromMap(Pokemon pokemon) {
		if (pokemonsOnMap.contains(pokemon)) {
			pokemon.move(null);
			pokemon.setCurrentFightMap(null);
			pokemonsOnMap.remove(pokemon);
			return true;
		} else {
			return false;
		}
	}

	public void unshadowAllBlocks() {
		for (int j = 0; j < sizeY; j++) {
			for (int i = 0; i < sizeX; i++) {
				map[j][i].setShadowed(false);
				map[j][i].setHighlight(false);
			}
		}
	}
	
	public ArrayList<Pokemon> getPlayerPokemonsOnMap() {
		return playerPokemonsOnMap;
	}
	
	public ArrayList<Pokemon> getEnemyPokemonsOnMap() {
		return enemyPokemonsOnMap;
	}
	
	public void checkInput() {
		
	}
	
	public static int getOriginX() {
		return originX;
	}
	
	public static int getOriginY() {
		return originY;
	}
	
	public static int getZoomLevel() {
		return zoomLevel;
	}

}
